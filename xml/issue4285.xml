<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4285" status="New">
<title>`time_get::do_get_date` is problematic even after LWG 461</title>
<section>
<sref ref="[locale.time.get.members]"/>
</section>
<submitter>S. B. Tam</submitter>
<date>27 Jun 2025</date>
<priority>3</priority>

<discussion>
<p>
Background: <a href="https://github.com/cplusplus/draft/pull/8009">https://github.com/cplusplus/draft/pull/8009</a>
<p/>
LWG <iref ref="461"/> changed `time_get::do_get_date` to parse a set of fixed formats. For example, if 
`time_get::date_order()` is `no_order` or `mdy`, the format parsed by `do_get_date` is `%m/%d/%y`.
<p/>
This has several problems:
</p>
<ol>
<li><p>When the resolution of LWG <iref ref="461"/> was applied to the draft standard, the slashes were lost. 
This could mislead people into implementing `do_get_date` using the incorrect formats. Fortunately, none 
of the standard library implementations are affected by this mistake.</p></li>
<li><p>Only 2-digit years are accepted due to the use of `%y`. This could lead to incorrect parse if 
`strftime` uses `%Y` for the locale's date format.</p></li>
<li><p>`date_order()` might need additional locale facets to find out the date order, but it doesn't have an 
<tt>ios_base&amp;</tt> argument from which to get the locale.</p></li>
<li><p>Many locales do not use any of the specified formats. For example, `de_DE` uses `%d.%m.%Y`, `zh_CN` 
uses `%Y年%m月%d日`. Although <sref ref="[locale.time.get.virtuals]"/>/5 gives an implementation the latitude 
to accept additional formats, ambiguity could arise if the locale's format disagrees with `date_order()`.</p></li>
</ol>
<p>
On POSIX systems, it is possible to query the locale's date format using `nl_langinfo(D_FMT)`. 
Maybe an implementation should be allowed to use that format <b>instead</b> of the one indicated by `date_order()`.
</p>

<note>2025-10-21; Reflector poll.</note>
<p>
Set priority to 3 after reflector poll.
</p>
<p>
"The current wording of `do_date_order()` suggests it should return one of the
`dmy`, `mdy`, `ymd`, `ymd`, or `ydm` enumerators as long as the date format
specified by `%x` has no components except day, month, and year.
But that fails to consider alternative separators between the components. 
The `kok_IN` locale uses `"%d-%m-%y" which does not contain
"other variable components" but still doesn't match any of the fixed formats
in Table 102.
We need normative wording allowing `no_order`, instead of just a footnoote,
and we need to say `do_get_date` only has to use the formats in the table
when `do_date_order() != no_order`. It should not default to the `mdy` format
when `do_date_order()` returns `no_order`, because if the `mdy` format is
correct then it should have returned `mdy`!"
</p>

<note>2025-10-21; Jonathan adds wording</note>
<p>
This restores the slashes lost by LWG <iref ref="461"/>
and attempts to make the use and effects of `no_order` more useful.
It does not attempt to address the problem that `do_date_order()`
has no access to an `ios_base` object.
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[locale.time.get.virtuals]"/> as indicated:</p>

<blockquote>
<pre>dateorder do_date_order() const;</pre>
<blockquote>
<p>-1- <i>Returns</i>:
An enumeration value indicating the preferred order of components for
those date formats that are composed of day, month, and year.<del><sup>228</sup></del>
Returns `no_order` if the date format specified by `'x'`
<del>
contains other variable components (e.g., Julian day, week number, week day)
</del>
<ins>
does not match one of the formats in Table [tab:locale.time.get.dogetdate]
</ins>
.
</p>
<blockquote>
<del>
228) This function is intended as a convenience only, for common formats,
and can return `no_order` in valid locales.
</del>
</blockquote>
</blockquote>

<pre>
iter_type do_get_time(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</pre>
<blockquote>[...]</blockquote>

<pre>
iter_type do_get_date(iter_type s, iter_type end, ios_base&amp; str,
                      ios_base::iostate&amp; err, tm* t) const;
</pre>
<blockquote>
<p>
<i>-4- Effects</i>:
Reads characters starting at s until it has extracted those `tm`
members and remaining format characters used by
<code>time_put&lt;&gt;::put</code>
to produce one of the following formats, or until it encounters an error.
The format depends on the value returned by `date_order()` as shown in
Table 102.
<ins>
When `do_date_order()` returns `no_order`, it is unspecified whether
the format shown in the table is used, or whether additional
implementation-defined formats are accepted.
</ins>
</p>
<p><ins>[<i>Note ?</i>:
For example, an implementation can accept dates in the format specified by
`'x'` as well as, or instead of, the format `"%m/%d/%y"`.
&mdash; <i>end note</i></ins>
</p>
<p><del>-5-
An implementation may also accept additional implementation-defined formats.
</del>
</p>
<p>-6- <i>Returns</i>:
An iterator pointing immediately beyond the last character recognized as
possibly part of a valid date.
</p>
</blockquote>

<p>Table 102 &mdash; `do_get_date` effects [tab:locale.time.get.dogetdate]</p>

<style>
table { border-collapse: separate; border-spacing: 0 6px; width: auto; }
thead, tbody { box-shadow: 0 0 0 1px black; border-spacing: 1em; }
th, td { padding-left: 0.5em; padding-right: 0.5em; }
</style>

<table>
<thead>
<tr> <th>`date_order()`</th><th>Format</th> </tr>
</thead>
<tbody>
<tr>
<td>`no_order`</td>
<td><code>"%m<ins>/</ins>%d<ins>/</ins>%y"</code></td></tr>
<tr>
<td>`dmy`</td>
<td><code>"%d<ins>/</ins>%m<ins>/</ins>%y"</code></td>
</tr>
<tr>
<td>`mdy`</td>
<td><code>"%m<ins>/</ins>%d<ins>/</ins>%y"</code></td>
</tr>
<tr>
<td>`ymd`</td>
<td><code>"%y<ins>/</ins>%m<ins>/</ins>%d"</code></td>
</tr>
<tr>
<td>`ydm`</td>
<td><code>"%y<ins>/</ins>%d<ins>/</ins>%m"</code></td>
</tr>
</tbody>
</table>

</blockquote>

</li>
</ol>

</resolution>

</issue>
