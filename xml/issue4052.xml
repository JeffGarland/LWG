<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4052" status="New">
<title>Bogus requirements for <code>piecewise_linear_distribution</code></title>
<section>
<sref ref="[rand.dist.samp.pconst]"/>
<sref ref="[rand.dist.samp.plinear]"/>
</section>
<submitter>Jonathan Wakely</submitter>
<date>05 Feb 2024</date>
<priority>4</priority>

<discussion>
<p>
In the second constructor of <sref ref="[rand.dist.samp.plinear]"/>,
<paper num="P1719R2"/> replaced:

<blockquote>
<pre><code>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                InputIteratorW firstW);
</code></pre>
<p>
<em>Effects</em>: [...] Moreover, the <em>id-expressions</em>
<code>iterator_traits&lt;InputIteratorB&gt;::value_type</code>
and
<code>iterator_traits&lt;InputIteratorW&gt;::value_type</code>
shall each denote a type that is convertible to
<code>double</code>.
</p>
</blockquote>
with
<blockquote>
<pre><code>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                InputIteratorW firstW);
</code></pre>
<p>
<em>Mandates</em>: 
<code>is_invocable_r_v&lt;double, UnaryOperation&amp;, double&gt;</code>
is <code>true</code>.
</p>
<p><em>Preconditions</em>: [...]</p>
<p><em>Effects</em>: [...]</p>

</blockquote>
</p>
<p>
This was a copy &amp; paste error from the next constructor,
and was obviously not intended. There is no <code>UnaryOperation</code>
in that constructor.
</p>
<p>A less obviously wrong issue is the use of <code>double</code> there
in the first place. Shouldn't it be <code>RealType</code> instead?
That seems to be incorrect throughout both
<sref ref="[rand.dist.samp.pconst]"/>
and
<sref ref="[rand.dist.samp.plinear]"/>,
and was only partially fixed by LWG <iref ref="1439"/>.
</p>

<p>
Finally, the  preconditions also say:
</p>
<blockquote>
<em>Preconditions</em>: [...]
If <code>firstB == lastB</code> or <code>++firstB == lastB</code>,
let <em>n</em> = 1, <em>ρ</em><sub>0</sub> = <em>ρ</em><sub>1</sub> = 1,
<em>b</em><sub>0</sub> = 0, and <em>b</em><sub>1</sub> = 1.
Otherwise, [<code>firstB</code>, <code>lastB</code>)
forms a sequence <em>b</em> of length <em>n</em> + 1,
the length of the sequence <em>w</em> starting
from <code>firstW</code> is at least <em>n</em>,
and any <em>w<sub>k</sub></em> for <em>k</em> ≥ <em>n</em>
are ignored by the distribution.
</blockquote>
<p>
These are not preconditions. I think it is trying to say something like:
</p>
<blockquote>
<p>
<em>Preconditions</em>: [...]
[<code>firstB</code>, <code>lastB</code>) is a valid range and
[<code>firstW</code>, <code>firstW + (lastB - firstB)</code>)
is a valid range.
</p>
<p>
<em>Effects</em>:
If <code>firstB == lastB</code> or <code>++firstB == lastB</code>,
let <em>n</em> = 1, <em>ρ</em><sub>0</sub> = <em>ρ</em><sub>1</sub> = 1,
<em>b</em><sub>0</sub> = 0, and <em>b</em><sub>1</sub> = 1.
Otherwise, let [<code>firstB</code>, <code>lastB</code>) form a sequence
<em>b</em><sub>0</sub>, &hellip;, <em>b</em><sub>n</sub>,
and let <em>w<sub>k</sub></em> = <code>*firstW++</code>
for <em>k</em> = 0, &hellip;, <em>n</em>.
</p>
</blockquote>

<p>
The equivalent constructor for <code>piecewise_constant_distribution</code>
has similar problems with its preconditions in terms of <em>n</em> + 1.
</p>

<note>2024-03-12; Reflector poll</note>
<p>
Set priority to 4 after reflector poll.
The copy &amp; paste error was
<a href="https://github.com/cplusplus/draft/pull/6794">fixed editorially</a>.
</p>

<note>2025-10-06; Hewill comments and provides wording</note>
<p>
We should fix the constructor, otherwise the following should be rejected according to the standard:
</p>
<blockquote><pre>
#include &lt;random&gt;

struct Op {
  float operator()(float);
  void operator()(auto) = delete;
};

static_assert(!std::is_invocable_r_v&lt;double, Op&amp;, double&gt;);

int main() {
  std::initializer_list&lt;float&gt; l;
  std::piecewise_linear_distribution&lt;float&gt; dist(l, Op{});
}
</pre></blockquote>
<p>
This is, because it violates <i>Mandates</i>. However, all three compilers accept it because 
<code>Op&amp;</code> can take `float` and return `float`.
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[rand.dist.samp.pconst]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                  InputIteratorW firstW);
</pre>
<blockquote>
<p>
-4- <i>Mandates</i>: Both of
</p>
<ol style="list-style-type: none">
<li><p>
(4.1) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorB>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
<li><p>
(4.2) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorW>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
</ol>
<p>
are `true`.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, UnaryOperation fw);
</pre>
<blockquote>
<p>
-7- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is `true`.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
</pre>
<blockquote>
<p>
-10- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is `true`.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>


<li><p>Modify <sref ref="[rand.dist.samp.plinear]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                InputIteratorW firstW);
</pre>
<blockquote>
<p>
-4- <i>Mandates</i>: Both of
</p>
<ol style="list-style-type: none">
<li><p>
(4.1) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorB>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
<li><p>
(4.2) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorW>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
</ol>
<p>
are `true`.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_linear_distribution(initializer_list&lt;RealType&gt; bl, UnaryOperation fw);
</pre>
<blockquote>
<p>
-7- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is `true`.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
</pre>
<blockquote>
<p>
-10- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is `true`.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>

</resolution>

</issue>
