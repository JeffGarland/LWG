<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4406" status="New">
<title>`optional::value_or` return statement is inconsistent with <i>Mandates</i></title>
<section>
<sref ref="[optional.observe]"/>
<sref ref="[optional.ref.observe]"/>
<sref ref="[expected.object.obs]"/>
</section>
<submitter>Hewill Kang</submitter>
<date>06 Sep 2025</date>
<priority>3</priority>

<discussion>
<p>
<code>optional&lt;T&gt;::value_or(U&amp;&amp;)</code> requires <code>is_convertible_v&lt;U&amp;&amp;, T&gt;</code> 
to ensure that `T` can be convert from `U` when `optional` has no value.
<p/>
However, the return statement explicitly constructs `T` by `static_cast`, which is not checked by 
`is_convertible_v` since it only checks for implicit conversions.
<p/>
This results in rare cases where <i>Mandates</i> may not be violated, but `value_or` is ill-formed 
(<a href="https://godbolt.org/z/z5jjhY7c4">demo</a>):
</p>
<blockquote><pre>
struct S {
  operator int() const;
  explicit operator int() = delete;
};

int main() {
   std::optional&lt;int&gt;{}.value_or(S{}); // <span style="color:#C80000;font-weight:bold">fire</span>
}
</pre></blockquote>
<p>
It is reasonable to create objects that stick to <i>Mandates</i>. The same goes for `expected::value_or`.
<p/>
<b>Daniel:</b>
<p/>
This issue has considerable overlap with LWG <iref ref="4281"/>.
</p>

<note>2025-10-16; Reflector poll</note>
<p>
Set priority to 3 after reflector poll.
</p>
<p>
This would need to use `val` instead of `**this` if LWG <iref ref="4015"/>
is accepted.
</p>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[optional.observe]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
-15- <i>Mandates</i>: <code>is_copy_constructible_v&lt;T&gt; &amp;&amp; is_convertible_v&lt;U&amp;&amp;, T&gt;</code> 
is `true`.
<p/>
-16- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<del>return has_value() ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));</del>
<ins>if (has_value())
  return **this;
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
-17- <i>Mandates</i>: <code>is_move_constructible_v&lt;T&gt; &amp;&amp; is_convertible_v&lt;U&amp;&amp;, T&gt;</code> 
is `true`.
<p/>
-18- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<del>return has_value() ? std::move(**this) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));</del>
<ins>if (has_value())
  return std::move(**this);
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify <sref ref="[optional.ref.observe]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr remove_cv_t&lt;T&gt; value_or(U&amp;&amp; u) const;
</pre>
<blockquote>
<p>
-8- Let <code>X</code> be <code>remove_cv_t&lt;T&gt;</code>.
<p/>
-9- <i>Mandates</i>: <code>is_constructible_v&lt;X, T&amp;&gt; &amp;&amp; is_convertible_v&lt;U, X&gt;</code> 
is `true`.
<p/>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<del>return has_value() ? *<i>val</i> : static_cast&lt;X&gt;(std::forward&lt;U&gt;(u));</del>
<ins>if (has_value())
  return *<i>val</i>;
return std::forward&lt;U&gt;(u);
</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify <sref ref="[expected.object.obs]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
-18- <i>Mandates</i>: <code>is_copy_constructible_v&lt;T&gt;</code> is `true` and 
<code>is_convertible_v&lt;U, T&gt;</code> is `true`.
<p/>
<del>-19- <i>Returns</i>: <code>has_value() ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v))</code>.</del>
<p/>
<ins>-?- <i>Effects</i>: Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>if (has_value())
  return **this;
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
-20- <i>Mandates</i>: <code>is_move_constructible_v&lt;T&gt;</code> is `true` and 
<code>is_convertible_v&lt;U, T&gt;</code> is `true`.
<p/>
<del>-21- <i>Returns</i>: <code>has_value() ? std::move(**this) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v))</code>.</del>
<p/>
<ins>-?- <i>Effects</i>: Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>if (has_value())
  return std::move(**this);
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>

</resolution>

</issue>
