<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4354" status="SG1">
<title>Reconsider `weakly_parallel` as the default `forward_progress_guarantee`</title>
<section>
<sref ref="[exec.get.fwd.progress]"/>
</section>
<submitter>Lewis Baker</submitter>
<date>25 Aug 2025</date>
<priority>1</priority>

<discussion>
<p>
The `get_forward_progress_guarantee` CPO is intended to allow querying a scheduler as for what sort of 
forward-progress guarantee it provides. Algorithms may use this to determine whether it is safe to execute 
certain operations on a given scheduler. If a scheduler does not customize this query, the query will 
fall back to returning a forward-progress guarantee of weakly_parallel.
<p/>
I think we should reconsider what this default should be returning and suggest it should instead return 
`parallel` by default, as this will be by far the most common kind of scheduler, i.e. a scheduler that 
executes on `std::thread`-like execution agents and that maintains a queue of scheduled tasks.
<p/>
I expect it to be common that authors of schedulers may forget to customize the 
`get_forward_progress_guarantee_t` query and just leave it at the default. This will likely leave their 
scheduler reporting a weaker guarantee than it actually provides and thus not being usable within generic 
algorithms that require at least parallel forward progress.
<p/>
For example, the `run_loop` execution context defined in <sref ref="[exec.run.loop]"/> does not define 
its scheduler to customize the `get_forward_progress_guarantee_t`. This means it will report the default 
value of `weakly_parallel`.
<p/>
However, the scheduled operations will run on the thread that calls `run_loop::run()` and thus will 
inherit its forward-progress guarantees. As this function might block and is therefore unsafe to invoke 
it from a thread/agent with `weakly_parallel` forward progress guarantees (which should probably be 
explicitly specified as having undefined-behaviour) we can safely assume that `run_loop`'s scheduler 
can provide parallel forward-progress guarantee.
<p/>
It's not clear whether the current `run_loop` specification defaulting to its scheduler having 
`weakly_parallel` forward progress guarantee is intentional or unintentional here. However, forgetting 
to define the `get_forward_progress_guarantee` query on a scheduler is something I expect to be fairly common.
<p/>
Schedulers that provide `weakly_parallel` (or in future, `concurrent`) forward progress guarantees require 
implementations to be much more aware of the fact that these are the guarantees they are providing and 
thus could be more expected to customize the `get_forward_progress_guarantee` query to return the 
respective values.
</p>

<note>2025-10-20; Reflector poll. Status changed: New &rarr; SG1</note>
<p>
Set priority to 1 after reflector poll. Send to SG1 and LEWG.
</p>
<p>
"If there is a default, it should be the weakest possible one.
If that is an unfortunate choice Iâ€™d rather prefer no default and mandate
that the query gets implemented. Providing a default which is stronger than
the weakest possible creates logic errors. Accidentally claiming weaker
than the actual value is only a performance error."
</p>
<p>
"This is tension between the default being promising the least and
the default being the most likely thing a user wants to do.
Assuming the least powerful guarantees unless the user has opted in is safer.
Changing this choice requires going back to LEWG or SG1."
</p>
<p>
"Plenty of reasonable schedulers are weakly parallel at best.
It's the right default. If your scheduler offers better than
that, you would naturally remember to customize it."
</p>
<p>
"It seems that the authors of `run_loop::scheduler` did not naturally remember to customize it.
It's possible the intent was that `run_loop::scheduler` should not offer better
than `weakly_parallel` forward progress, but it was not discussed in P2300.
The absence of an explicit implementation of the query could either be
intentional or an accidental omission.
Perhaps this is an indication that there should not be a default forward-progress guarantee for schedulers?"
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[exec.get.fwd.progress]"/> as indicated:</p>

<blockquote>
<p>
-2- The name `get_forward_progress_guarantee` denotes a query object. For a subexpression `sch`, let `Sch`
be `decltype((sch))`. If `Sch` does not satisfy `scheduler`, `get_forward_progress_guarantee` is ill-formed.
Otherwise, `get_forward_progress_guarantee(sch)` is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <tt><i>MANDATE-NOTHROW</i>(<i>AS-CONST</i>(sch).query(get_forward_progress_guarantee))</tt> 
if that expression is well-formed.
<p/>
<i>Mandates</i>: The type of the expression above is `forward_progress_guarantee`.
</p></li>
<li><p>(2.2) &mdash; Otherwise, <tt>forward_progress_guarantee::<del>weakly_</del>parallel</tt>.</p></li>
</ol>

</blockquote>

</li>

</ol>
</resolution>

</issue>
