<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3967" status="New">
<title>The specification for <tt>std::is_nothrow_*</tt> traits may be ambiguous in some cases involving <tt>noexcept(false)</tt></title>
<section><sref ref="[meta.unary.prop]"/></section>
<submitter>Jiang An</submitter>
<date>04 Aug 2023</date>
<priority>3</priority>

<discussion>
<p>
<tt>std::is_nothrow_*</tt> traits are currently specified in the form "(some operation) is known not to throw any exceptions". 
Under the following circumstance, the current specification may be ambiguous:
</p>
<ul>
<li><p>a trait detects an explicitly defaulted special member function, and</p></li>
<li><p>the implicit except specification of that function would be <tt>noexcept(true)</tt>, but</p></li>
<li><p>the function is explicitly marked with <tt>noexcept(false)</tt>.</p></li>
</ul>
<p>
It seems that an implementation may decompose the defaulted special member function and then conclude that the trait 
should give a <tt>true</tt> result, or may just use the exception specification which gives a <tt>false</tt> result.
<p/>
Implementors seemingly hold different opinions, see <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106611">GCC Bug 106611</a> 
and <a href="https://quuxplusone.github.io/blog/2023/04/17/noexcept-false-equals-default/">this blog post</a>.
<p/> 
Perhaps we may need to clarify that the implementation divergence is permitted, or unambiguously specify these 
traits to give results consistent with exception specifications.
</p>

<note>2025-10-17; Reflector poll.</note>
<p>
Set priority to 3 after reflector poll.
</p>
<p>
"NAD, this was just a GCC bug."
</p>

<note>2025-10-18; Arthur provides wording</note>

</discussion>

<resolution>

<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>
Modify <sref ref="[tab:meta.unary.prop]"/>, Table 54 Type property predicates,
as indicated:
</p>

<table style="border-spacing: 4em; border-style: none; text-align: center">
<tr>
<th>Template</th><th>Condition</th><th>Preconditions</th>
</tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr style="text-align: left; vertical-align: top">
<td>
<pre>
template&lt;class T, class... Args&gt;
struct is_nothrow_constructible;
</pre>
</td>
<td>
<code>is_constructible_v&lt;T, Args...&gt;</code> is `true` and
the variable definition for `is_constructible`, as defined below,
<ins>
contains no potentially-throwing expression (<sref ref="[except.spec]"/>)
</ins>
<del>is known not to throw any exceptions
(<sref ref="[expr.unary.noexcept]"/>)</del>.
</td>
<td>
`T` and all types in the template parameter pack `Args` shall be complete types,
<i>cv</i> `void`, or arrays of unknown bound.
</td>
</tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
</table>
</li>
</ol>

</resolution>

</issue>
