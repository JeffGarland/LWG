<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4322" status="New">
<title>Problematic <i>Constraints</i> on incomplete types in indirect and polymorphic</title>
<section>
<sref ref="[mem.composite.types]"/>
</section>
<submitter>Jonathan B. Coe</submitter>
<date>20 Aug 2025</date>
<priority>2</priority>

<discussion>
<p>
The class templates <tt>indirect&lt;T&gt;</tt> and <tt>polymorphic&lt;T&gt;</tt> allow the template argument `T` 
to be an incomplete type.
<p/>
Both classes can be instantiated when the type `T` is incomplete: constraints are written so that requirements 
on incomplete types are not evaluated at class instantiation time.
<p/>
For constructors with additional template parameters, there are currently constraints written on the potentially 
incomplete type `T` and the additional template parameters. Such constraints will not be evaluated at class 
instantiation time but could be explicitly evaluated in contexts where support for an incomplete `T` is required.
</p>
<blockquote><pre>
template&lt;typename U&gt;
class A {
  U u;
public:
  A(const <i>SomeType</i>&amp;) requires std::is_constructible_v&lt;U, <i>SomeType</i>&gt; 
  {
    // [&hellip;]
  }
};
</pre></blockquote>
<p>
when `U` is <tt>indirect&lt;T&gt;</tt> or <tt>polymorphic&lt;T&gt;</tt> for some type `T`, the existence 
of the requires clause will require that `T` is a complete type for constraints on indirect or polymorphic 
to be evaluated.
<p/>
<i>Constraints</i> on `T` should be converted to <i>Mandates</i> on `T` so that constraint evaluation 
does not require `T` to be a complete type.
</p>

<note>2025-10-07; Reflector poll</note>
<p>
Set priority to 2 after reflector poll.
</p>
<p>
"Do we have a concrete use case of an A-like type? Is making the traits give
wrong answers preferable to hard errors? I don't think the `polymorphic` part
makes sense. Since the constraints still require `U`/`UU` to be complete,
either `T` is a base class and it must be complete, or it is not and it doesn't
matter."
</p>
<p>
"The problematic members are non-template functions, so they are instantiated
early and the requires clauses are checked too soon. Think this can be solved
without giving up SFINAE-friendliness, by making the affected members
themselves templates."
</p>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[indirect.ctor]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit indirect(U&amp;&amp; u);
</pre>
<blockquote>
<p>
-17- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(17.1) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, indirect&gt;</tt> is `false`,</p></li>
<li><p>(17.2) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, in_place_t&gt;</tt> is `false`, <ins>and</ins></p></li>
<li><p><del>(17.3) &mdash; <tt>is_constructible_v&lt;T, U&gt;</tt> is `true`, and</del></p></li>
<li><p>(17.4) &mdash; <tt>is_default_constructible_v&lt;Allocator&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is `true`.</ins>
<p/>
-18- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit indirect(allocator_arg_t, const Allocator&amp; a, U&amp;&amp; u);
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(19.1) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, indirect&gt;</tt> is `false`, <ins>and</ins></p></li>
<li><p>(19.2) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, in_place_t&gt;</tt> is `false`<ins>.</ins><del>, and</del></p></li>
<li><p><del>(19.3) &mdash; <tt>is_constructible_v&lt;T, U&gt;</tt> is `true`</del></p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is `true`.</ins>
<p/>
-20- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Us&gt;
  constexpr explicit indirect(in_place_t, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-21- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(21.1) &mdash; <tt>is_constructible_v&lt;T, Us...&gt;</tt> is `true`, and</del></p></li>
<li><p><del>(21.2) &mdash;</del> <tt>is_default_constructible_v&lt;Allocator&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>is_constructible_v&lt;T, Us...&gt;</tt> is `true`.</ins>
<p/>
-22- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Us&gt;
  constexpr explicit indirect(allocator_arg_t, const Allocator&amp; a,
                              in_place_t, Us&amp;&amp; ...us);
</pre>
<blockquote>
<p>
-23- <i><del>Constraints</del><ins>Mandates</ins></i>: <tt>is_constructible_v&lt;T, Us...&gt;</tt> is `true`
<p/>
-24- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class I, class... Us&gt;
  constexpr explicit indirect(in_place_t, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-25- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(25.1) &mdash; <tt>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</tt> is `true`, and</del></p></li>
<li><p><del>(25.2) &mdash;</del> <tt>is_default_constructible_v&lt;Allocator&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</tt> is `true`.</ins>
<p/>
<p/>
-26- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class I, class... Us&gt;
  constexpr explicit indirect(allocator_arg_t, const Allocator&amp; a,
                              in_place_t, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-27- <i><del>Constraints</del><ins>Mandates</ins></i>: <tt>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</tt> 
is `true`
<p/>
-28- <i>Effects</i>: [&hellip;]
</p>
</blockquote>

</blockquote>

</li>

<li><p>Modify <sref ref="[polymorphic.ctor]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit polymorphic(U&amp;&amp; u);
</pre>
<blockquote>
<p>
-12- <i>Constraints</i>: Where `UU` is <tt>remove_cvref_t&lt;U&gt;</tt>,
</p>
<ol style="list-style-type: none">
<li><p>(12.1) &mdash; <tt>is_same_v&lt;UU, polymorphic&gt;</tt> is `false`,</p></li>
<li><p><del>(12.2) &mdash; <tt>derived_from&lt;UU, T&gt;</tt> is `true`,</del></p></li>
<li><p>(12.3) &mdash; <tt>is_constructible_v&lt;UU, U&gt;</tt> is `true`,</p></li>
<li><p>(12.4) &mdash; <tt>is_copy_constructible_v&lt;UU&gt;</tt> is `true`,</p></li>
<li><p>(12.5) &mdash; `UU` is not a specialization of `in_place_type_t`, and</p></li>
<li><p>(12.6) &mdash; <tt>is_default_constructible_v&lt;Allocator&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>derived_from&lt;UU, T&gt;</tt> is `true`.</ins>
<p/>
-13- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit polymorphic(allocator_arg_t, const Allocator&amp; a, U&amp;&amp; u);
</pre>
<blockquote>
<p>
-14- <i>Constraints</i>: Where `UU` is <tt>remove_cvref_t&lt;U&gt;</tt>,
</p>
<ol style="list-style-type: none">
<li><p>(14.1) &mdash; <tt>is_same_v&lt;UU, polymorphic&gt;</tt> is `false`,</p></li>
<li><p><del>(14.2) &mdash; <tt>derived_from&lt;UU, T&gt;</tt> is `true`,</del></p></li>
<li><p>(14.3) &mdash; <tt>is_constructible_v&lt;UU, U&gt;</tt> is `true`,</p></li>
<li><p>(14.4) &mdash; <tt>is_copy_constructible_v&lt;UU&gt;</tt> is `true`, and</p></li>
<li><p>(14.5) &mdash; `UU` is not a specialization of `in_place_type_t`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>derived_from&lt;UU, T&gt;</tt> is `true`.</ins>
<p/>
-15- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class... Ts&gt;
  constexpr explicit polymorphic(in_place_type_t&lt;U&gt;, Ts&amp;&amp;... ts);
</pre>
<blockquote>
<p>
-16- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(16.1) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</tt> is `true`,</p></li>
<li><p><del>(16.2) &mdash; <tt>derived_from&lt;U, T&gt;</tt> is `true`,</del></p></li>
<li><p>(16.3) &mdash; <tt>is_constructible_v&lt;U, Ts&gt;</tt> is `true`,</p></li>
<li><p>(16.4) &mdash; <tt>is_copy_constructible_v&lt;U&gt;</tt> is `true`, and</p></li>
<li><p>(16.5) &mdash; <tt>is_default_constructible_v&lt;Allocator&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>derived_from&lt;U, T&gt;</tt> is `true`.</ins>
<p/>
-17- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class... Ts&gt;
  constexpr explicit polymorphic(allocator_arg_t, const Allocator&amp; a,
                                 in_place_type_t&lt;U&gt;, Ts&amp;&amp;... ts);
</pre>
<blockquote>
<p>
-18- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(18.1) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</tt> is `true`,</p></li>
<li><p><del>(18.2) &mdash; <tt>derived_from&lt;U, T&gt;</tt> is `true`,</del></p></li>
<li><p>(18.3) &mdash; <tt>is_constructible_v&lt;U, Ts&gt;</tt> is `true`, and</p></li>
<li><p>(18.4) &mdash; <tt>is_copy_constructible_v&lt;U&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>derived_from&lt;U, T&gt;</tt> is `true`.</ins>
<p/>
-19- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class I, class... Us&gt;
  constexpr explicit polymorphic(in_place_type_t&lt;U&gt;, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-20- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(20.1) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</tt> is `true`,</p></li>
<li><p><del>(20.2) &mdash; <tt>derived_from&lt;U, T&gt;</tt> is `true`,</del></p></li>
<li><p>(20.3) &mdash; <tt>is_constructible_v&lt;U, initializer_list&lt;I&gt;&amp;, Us...&gt;</tt> is `true`,</p></li>
<li><p>(20.4) &mdash; <tt>is_copy_constructible_v&lt;U&gt;</tt> is `true`, and</p></li>
<li><p>(20.5) &mdash; <tt>is_default_constructible_v&lt;Allocator&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>derived_from&lt;U, T&gt;</tt> is `true`.</ins>
<p/>
-21- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class I, class... Us&gt;
  constexpr explicit polymorphic(allocator_arg_t, const Allocator&amp; a, 
                                 in_place_type_t&lt;U&gt;, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-22- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(22.1) &mdash; <tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</tt> is `true`,</p></li>
<li><p><del>(22.2) &mdash; <tt>derived_from&lt;U, T&gt;</tt> is `true`,</del></p></li>
<li><p>(22.3) &mdash; <tt>is_constructible_v&lt;U, initializer_list&lt;I&gt;&amp;, Us...&gt;</tt> is `true`, and</p></li>
<li><p>(22.4) &mdash; <tt>is_copy_constructible_v&lt;U&gt;</tt> is `true`.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <tt>derived_from&lt;U, T&gt;</tt> is `true`.</ins>
<p/>
-23- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>
</resolution>

</issue>
