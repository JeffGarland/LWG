<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4367" status="New">
<title>Improve <code>optional&lt;T&amp;&gt;::or_else</code></title>
<section>
<sref ref="[optional.ref.monadic]"/>
</section>
<submitter>Hewill Kang</submitter>
<date>07 Sep 2025</date>
<priority>4</priority>

<discussion>
<p>
<code>optional&lt;T&amp;&gt;::or_else</code> currently returns <code>*<i>val</i></code> when it has a value,
which calls the <code>optional(U&amp;&amp;)</code> constructor which in turn calls 
<code><i>convert-ref-init-val</i></code> which in turn calls `addressof`.
<p/>
There's no reason to do that. It's much more efficient to call <code>optional&lt;T&amp;&gt;</code>'s 
default copy constructor to just copy a pointer.
</p>

<note>2025-10-16; Reflector poll</note>
<p>
Set priority to 4 after reflector poll.
</p>
<p>
"NAD, no observable difference."
"Still simpler to not have to reason about whether it matters, let's do it."
</p>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[optional.ref.monadic]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt; constexpr optional or_else(F&amp;&amp; f) const;
</pre>
<blockquote>
<p>
-7- <i>Constraints</i>: `F` models `invocable`.
<p/>
-8- <i>Mandates</i>: <code>is_same_v&lt;remove_cvref_t&lt;invoke_result_t&lt;F&gt;&gt;, optional&gt;</code> is `true`.
<p/>
-9- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (has_value()) {
  return *<ins>this</ins><del><i>val</i></del>;
} else {
  return std::forward&lt;F&gt;(f)();
}
</pre></blockquote></blockquote>
</blockquote>

</li>

</ol></resolution>

</issue>
