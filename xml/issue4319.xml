<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4319" status="New">
<title>Supporting copy-elision in function wrappers</title>
<section>
<sref ref="[func.require]"/>
</section>
<submitter>Tomasz Kami≈Ñski</submitter>
<date>19 Aug 2025</date>
<priority>3</priority>

<discussion>
<p>
The wording for argument forwarding call wrappers in <sref ref="[func.require]"/> p3,
</p>
<blockquote><p>
This forwarding step delivers rvalue arguments as rvalue references and lvalue arguments 
as lvalue references.
</p></blockquote>
<p>
requires that each wrapper binds a temporary to rvalue reference
(materializing it), and then pass that xvalue. This essentially
codifies an implementation where wrappers provide an `operator()` that
accepts <tt>Args&amp;&amp;...</tt>. This is fine for most of the wrappers.
<p/>
For some wrappers more efficient implementation strategies are possible:
</p>
<ul>
<li><p>`bind_front(f)/bind_back(f)` without bound args could return a copy of `f`</p></li>
<li><p><tt>bind_front&lt;f&gt;()/bind_back&lt;f&gt;()</tt> could produce a 
<tt>__function_wrapper&lt;f&gt;</tt>, that for function pointers can be invoked using 
a surrogate function call.</p></li>
</ul>
<p>
However, such implementation strategies are currently disallowed per
<sref ref="[func.require]"/> p3, as invoking the function wrapper with 
a prvalue `bind_front(f)(T())` requires a temporary to be materialized, 
and then moved into the parameter of `f`. For example:
</p>
<blockquote><pre>
struct M 
{
  M() { std::cout &lt;&lt; "Default" &lt; std::endl; }
  M(M&amp;&amp; m) { std::cout &lt;&lt; "Move" &lt; std::endl; }
};

struct F
{ 
  void operator()(M m) {} 
} f;
</pre></blockquote>
<p>
The call `f(M{})` will print only "`Default`" but `bind_front(f)(M{})` is
required to produce "`Default`" and "`Move`". We should allow
implementations to elide the move operations, but not require it.
</p>
<p>
The suggested changes by this issue have been 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-August/062992.html">implemented in libstdc++</a>
for `bind_front/bind_back`.
</p>

<note>2025-10-14; Reflector poll</note>
<p>
Set priority to 3 after reflector poll.
</p>
<p>
The submitter prefers to withdraw the issue because the proposed resolution
changes the result of overload resolution in unspecified ways. It would
no longer be specified whether `bind_front(F{})({})` works or not,
as it would depend whether `bind_front(F{})` returned a call wrapper or the
`F` object without wrapping. It would also make the effects of
`bind_front(S{})(0, 0)` unspecified if the call could resolve to either
`S::operator()(long, long)` or `S::operator()(int, void*)`, depending on
whether `bind_front(S{})` returns a call wrapper or the `S` object.
</p>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[func.require]"/> as indicated:</p>

<blockquote>
<p>
-3- Every call wrapper (<sref ref="[func.def]"/>) meets the <i>Cpp17MoveConstructible</i> and 
<i>Cpp17Destructible</i> requirements. An <i>argument forwarding call wrapper</i> is a call wrapper 
that can be called with an arbitrary argument list and delivers the arguments to the target object 
<del>as references</del>. This forwarding step delivers <del>rvalue arguments as rvalue references 
and lvalue arguments as lvalue references.</del><ins>:</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(3.?) &mdash; lvalue arguments as lvalues,</ins></p></li>
<li><p><ins>(3.?) &mdash; xvalue arguments as xvalues,</ins></p></li>
<li><p><ins>(3.?) &mdash; prvalue arguments as either prvalues or xvalues.</ins></p></li>
</ol>
</blockquote>

</li>

</ol>
</resolution>

</issue>
